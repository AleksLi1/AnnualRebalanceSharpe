import pandas as pd
import warnings
import numpy as np
import pandas_market_calendars as mcal
from pypfopt import EfficientFrontier, expected_returns, DiscreteAllocation, get_latest_prices, objective_functions
from datetime import datetime, timedelta
from Functions import quarterly_cov
import yfinance as yf

# Ignore warnings
warnings.simplefilter("ignore", UserWarning)  # Ignore UserWarning generated by .add_objective in pypfopt

# Define variables
# I used some of the ETFs recommended in pg.11 of: https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3272080
tickers = ['GLD', 'MDY', 'QQQ', 'SPY', 'TLT', 'VBR', 'VTV', 'PSQ']
portfolio_value = 9200  # Amount in dollars for initial portfolio value

# Get data
today = datetime.now()
quarter = today - timedelta(days=90)
today = today.strftime('%Y-%m-%d')
quarter = quarter.strftime('%Y-%m-%d')
prices = yf.download(tickers, start=quarter, end=today)['Adj Close'].dropna()

# Add cash
prices['CASH'] = 1

# Process ticker data
tickers = prices.columns
length = len(prices.index)
prices.index = pd.to_datetime(prices.index)
daily_ret = np.log(prices / prices.shift(1))[1:]
daily_ret_col = list(daily_ret.columns)
quarter_ret = daily_ret.groupby(pd.Grouper(freq='3M')).apply(np.sum)

# Get Dates
start = prices.index[0].strftime('%Y-%m-%d')
end = prices.index[-1].strftime('%Y-%m-%d')
training_date_range = [start, end]

# Get NYSE trading calendar
nyse = mcal.get_calendar('NYSE')

# Perform weights dataframe calculations
weights = pd.DataFrame()
allocation_shares = pd.DataFrame()

# Main portfolio calculations happen here. Certain operations in this block require the GLPK_MI solver for CVXPY,
# which you can install by following these instructions: http://cvxopt.org/install/index.html
# You can also check the solvers installed on your environment by using the 'print(cvxpy.installed_solvers())' operation

# Configure range
nyse_trading_date_range = nyse.schedule(start, end)
nyse_trading_date_range_index = mcal.date_range(nyse_trading_date_range, frequency='1D')\
    .strftime('%Y-%m-%d')\
    .tolist()

# Pull relevant price data
prices_dataframe = prices.loc[datetime.strptime(str(nyse_trading_date_range_index[0]), '%Y-%m-%d'):
                              datetime.strptime(str(nyse_trading_date_range_index[-1]), '%Y-%m-%d')]

# Calculate efficient frontier with given covariance matrix and expected returns
prices_expected_returns = expected_returns.ema_historical_return(prices_dataframe)
covariance_matrix = quarterly_cov(nyse_trading_date_range_index[0], prices_expected_returns, tickers, length)
ef = EfficientFrontier(prices_expected_returns, covariance_matrix)

# Optimise portfolio and give weights
raw_weights = ef.nonconvex_objective(
    objective_functions.sharpe_ratio,
    objective_args=(ef.expected_returns, ef.cov_matrix),
    weights_sum_to_one=True,
)
cleaned_weights = ef.clean_weights()

# Append weights to dataframe 'weights'
cleaned_weights = dict(cleaned_weights)
weights = weights.append(dict(cleaned_weights), ignore_index=True)

# Get allocation in shares
latest_prices = get_latest_prices(prices_dataframe)
da = DiscreteAllocation(cleaned_weights, latest_prices, total_portfolio_value=portfolio_value)
allocation, leftover = da.lp_portfolio()
allocation_shares = allocation_shares.append(dict(allocation), ignore_index=True)

# Show other portfolio statistics
print('-------------------------------------------------------------------')
print('Calculations performed for period between {} and {}'.format(quarter, today))
print('-------------------------------------------------------------------')
print("Recommended portfolio weights (by percent) for the next 3 months:")
print(weights.iloc[-1].to_string())
print('-------------------------------------------------------------------')
print("Recommended portfolio weights (by shares) for the next 3 months:")
print(allocation_shares.iloc[-1].to_string())
print('-------------------------------------------------------------------')
