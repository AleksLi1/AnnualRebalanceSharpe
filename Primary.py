import pandas as pd
import warnings
import numpy as np
import yfinance as yf
import pandas_market_calendars as mcal
from pypfopt import (EfficientFrontier, objective_functions, expected_returns, DiscreteAllocation, get_latest_prices)
from datetime import datetime
from Functions import annual_cov, start_date
import matplotlib.pyplot as plt

# Ignore warnings
warnings.simplefilter("ignore", UserWarning)  # Ignore UserWarning generated by .add_objective in pypfopt


# Define variables
tickers = ['SPY', 'VBR', 'TLT', 'MDY', 'QQQ']
benchmark = ['SPY']
start = '2005-01-01'
end = '2020-12-31'
training_years = 1  # Number of years for which we calculate the expected return and covariance data
portfolio_value = 10000  # Amount in dollars for initial portfolio value


# Get and process price data
# Ticker data
prices = yf.download(tickers=tickers, start=start, end=end)['Adj Close']
daily_ret = np.log(prices / prices.shift(1))[1:]
daily_ret_col = list(daily_ret.columns)
annual_ret = daily_ret.groupby(pd.Grouper(freq='Y')).apply(np.sum)

# Benchmark data
prices_benchmark = yf.download(tickers=benchmark, start=start, end=end)['Adj Close']
prices_benchmark_daily_ret = np.log(prices_benchmark / prices_benchmark.shift(1))[1:]


# Create list of trading days between start date and end date of training set
# Earliest and latest date of a year
start_years = []
end_years = pd.date_range(start, end, freq='y').strftime('%Y-%m-%d').tolist()
for x in end_years:
    start_years.append(start_date(x))

# Get NYSE trading calendar
nyse = mcal.get_calendar('NYSE')
training_date_range = list(zip(start_years, end_years))


# Perform weights dataframe calculations
weights = pd.DataFrame()
trading_start_dates = []
trading_end_dates = []
for k, v in training_date_range:

    # Configure range of a trading year
    nyse_trading_date_range = nyse.schedule(k, v)
    nyse_trading_date_range_index = mcal.date_range(nyse_trading_date_range, frequency='1D')\
        .strftime('%Y-%m-%d')\
        .tolist()
    trading_start_dates.append(nyse_trading_date_range_index[0])
    trading_end_dates.append(nyse_trading_date_range_index[-1])

    # Pull relevant price data for given trading year range
    prices_dataframe = prices.loc[datetime.strptime(str(nyse_trading_date_range_index[0]), '%Y-%m-%d'):datetime.strptime(str(nyse_trading_date_range_index[-1]), '%Y-%m-%d')]

    # Calculate efficient frontier with given covariance matrix and expected returns
    prices_expected_returns = expected_returns.ema_historical_return(prices_dataframe)
    covariance_matrix = annual_cov(training_years, nyse_trading_date_range_index[0], prices_expected_returns, tickers)
    ef = EfficientFrontier(prices_expected_returns, covariance_matrix)

    # Optimise portfolio and give weights
    raw_weights = ef.max_sharpe()
    ef.add_objective(objective_functions.L2_reg, gamma=1)  # Objective to discourage zero-weights
    cleaned_weights = ef.clean_weights()

    # Append weights to dataframe 'weights'
    cleaned_weights = dict(cleaned_weights)
    weights = weights.append(dict(cleaned_weights), ignore_index=True)

    # Get allocation in shares (unused for now)
#    latest_prices = get_latest_prices(prices_dataframe)
#    da = DiscreteAllocation(cleaned_weights, latest_prices, total_portfolio_value=portfolio_value)
#    allocation, leftover = da.lp_portfolio()

# Clean up weights dataframe
trading_start_years = []
for x in trading_start_dates:
    four_digit_year = x[0:4]
    trading_start_years.append(four_digit_year)
weights.index = trading_start_years

# Create a daily weights dataframe
daily_trading_days = mcal.date_range(nyse.schedule(start, end), frequency='1D')\
        .strftime('%Y-%m-%d')\
        .tolist()
daily_weights = pd.DataFrame(np.repeat(weights.values, 252, axis=0))
daily_weights.columns = weights.columns
daily_weights.drop(daily_weights.tail(4).index, inplace=True)  # Temporary solution, dropping extra 4 rows from df
daily_weights.index = daily_trading_days


# Calculate weighted stock returns
daily_trading_days_modified = daily_trading_days[:-1]  # Temporary solution, dropping extra 1 item from list
daily_ret.index = daily_trading_days_modified
daily_weights_returns = daily_weights.mul(daily_ret).dropna()
daily_weights_returns.columns = daily_ret_col

# Create total returns column
daily_weights_returns['Daily Pct Return'] = daily_weights_returns.sum(axis=1)+1

# Create portfolio value column
daily_weights_returns = daily_weights_returns.reset_index(drop=False)
daily_weights_returns['Portfolio Value'] = np.nan
daily_weights_returns.at[0, 'Portfolio Value'] = portfolio_value
for i, row in daily_weights_returns.iterrows():  # Loop by iterrows: fight me (or please suggest something better)
    if i == 0:
        daily_weights_returns.loc[i, 'Portfolio Value'] = daily_weights_returns['Portfolio Value'].iat[0]
    else:
        daily_weights_returns.loc[i, 'Portfolio Value'] = daily_weights_returns.loc[i, 'Daily Pct Return'] * \
                                                daily_weights_returns.loc[i - 1, 'Portfolio Value']


# Process benchmark data
prices_benchmark_daily_ret = prices_benchmark_daily_ret.to_frame().reset_index(drop=False)
prices_benchmark_daily_ret['Portfolio Value'] = np.nan
prices_benchmark_daily_ret.loc[[0], ['Portfolio Value']] = portfolio_value
prices_benchmark_daily_ret.rename(columns={prices_benchmark_daily_ret.columns[0]: 'Daily Pct Return'}, inplace=True)
prices_benchmark_daily_ret['Daily Pct Return'] = prices_benchmark_daily_ret.sum(axis=1)+1
for i, row in prices_benchmark_daily_ret.iterrows():
    if i == 0:
        prices_benchmark_daily_ret.loc[i, 'Portfolio Value'] = prices_benchmark_daily_ret['Portfolio Value'].iat[0]
    else:
        prices_benchmark_daily_ret.loc[i, 'Portfolio Value'] = prices_benchmark_daily_ret.loc[i, 'Daily Pct Return'] * \
                                                prices_benchmark_daily_ret.loc[i - 1, 'Portfolio Value']
prices_benchmark_daily_ret['index'] = daily_trading_days_modified


# Plot portfolio value and benchmark
spacing = 10
fig, ax = plt.subplots(figsize=(10, 6))
plt1 = plt.plot(prices_benchmark_daily_ret['index'], prices_benchmark_daily_ret['Portfolio Value'], label=benchmark[0])
plt2 = plt.plot(daily_weights_returns['index'], daily_weights_returns['Portfolio Value'], label='Portfolio Value')
plt.legend()
plt.xticks(rotation=45)

# Reduce number of labels
functions = [plt1, plt2]
for fn in functions:
    visible = ax.xaxis.get_ticklabels()[::spacing]
    for label in ax.xaxis.get_ticklabels():
        if label not in visible:
            label.set_visible(False)

plt.title('Annually rebalanced portfolio performance, optimised for Sharpe')
plt.xlabel('Date')
plt.ylabel('Portfolio Value')

plt.show()
