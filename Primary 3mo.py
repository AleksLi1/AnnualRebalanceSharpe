import pandas as pd
import warnings
import numpy as np
import pandas_market_calendars as mcal
import matplotlib.pyplot as plt
from pypfopt import EfficientFrontier, expected_returns, expected_returns, EfficientFrontier, objective_functions
from datetime import datetime
from Functions import *
from scipy.stats import skew, kurtosis
import quantstats as qs

# Ignore warnings
warnings.simplefilter("ignore", FutureWarning)  # Ignore UserWarning generated by .add_objective in pypfopt

# Get and process data
# Ticker data
prices = pd.read_csv('data/Risk-Parity Main - OUTPUT.csv', index_col=0).dropna()
prices.index = pd.to_datetime(prices.index)
tickers = prices.columns
daily_ret = np.log(prices / prices.shift(1))[1:]
portfolio_value = 10000

# Benchmark data
benchmark = ['QQQ']
prices_benchmark_daily_ret = np.log(prices[benchmark] / prices[benchmark].shift(1))[1:]

backtest_monhts = 3
test_days = 21*backtest_monhts
trading_months = 1
trading_days = 21*trading_months

weights_df = pd.DataFrame()

backtest_frame = pd.DataFrame()
backtest_frame = backtest_frame.append(dict(enumerate(np.zeros(len(tickers)))), ignore_index=True)
backtest_frame = pd.DataFrame(np.repeat(backtest_frame.values, test_days, axis=0))
backtest_frame.columns = tickers

# Main portfolio calculations happen here. Certain operations in this block require the GLPK_MI solver for CVXPY,
# which you can install using these instructions: http://cvxopt.org/install/index.html
# You can also check the solvers installed on your environment by using the 'print(cvxpy.installed_solvers())' operation
for z in range(test_days,len(prices),trading_days):

    test = prices.iloc[z-test_days:z,:]
    mu = expected_returns.ema_historical_return(test)
    Sigma = cov_matrix_based(test)

    ef = EfficientFrontier(mu, Sigma)

    weights = ef.nonconvex_objective(
    objective_functions.sharpe_ratio,
    objective_args=(ef.expected_returns, ef.cov_matrix),
    weights_sum_to_one=True,
    )

    cleaned_weights = ef.clean_weights()
    cleaned_weights = dict(cleaned_weights)
    weights_df = weights_df.append(cleaned_weights, ignore_index=True)

    print(test)
    print(cleaned_weights)

# Creating Daily Weights DF from test data -> this will be our backtest data
weights_df = weights_df[:-1]
weights_df = pd.DataFrame(np.repeat(weights_df.values, trading_days, axis=0))
weights_df.columns = tickers
daily_weights = pd.concat([backtest_frame, weights_df])
daily_ret = daily_ret.iloc[:-(len(daily_ret)-len(daily_weights))]
daily_weights = daily_weights.set_index(daily_ret.index, inplace=False)
daily_weights.columns = tickers
daily_weights_returns = daily_weights.mul(daily_ret)

daily_weights.to_csv('weights.csv')

# Create total returns and portfolio value columns
daily_weights_returns['Daily Pct Return'] = daily_weights_returns.sum(axis=1)+1
daily_weights_returns = daily_weights_returns.reset_index(drop=False)
daily_weights_returns['Portfolio Value'] = np.nan
daily_weights_returns.at[0, 'Portfolio Value'] = portfolio_value
for i, row in daily_weights_returns.iterrows():
    if i == 0:
        daily_weights_returns.loc[i, 'Portfolio Value'] = daily_weights_returns['Portfolio Value'].iat[0]
    else:
        daily_weights_returns.loc[i, 'Portfolio Value'] = daily_weights_returns.loc[i, 'Daily Pct Return'] * \
                                                daily_weights_returns.loc[i - 1, 'Portfolio Value']
        
# Process benchmark data
prices_benchmark_daily_ret = prices_benchmark_daily_ret.reset_index(drop=False)
prices_benchmark_daily_ret['Portfolio Value'] = np.nan
prices_benchmark_daily_ret.loc[[0], ['Portfolio Value']] = portfolio_value
prices_benchmark_daily_ret.rename(columns={prices_benchmark_daily_ret.columns[0]: 'Daily Pct Return'}, inplace=True)
prices_benchmark_daily_ret['Daily Pct Return'] = prices_benchmark_daily_ret.sum(axis=1)+1
for i, row in prices_benchmark_daily_ret.iterrows():
    if i == 0:
        prices_benchmark_daily_ret.loc[i, 'Portfolio Value'] = prices_benchmark_daily_ret['Portfolio Value'].iat[0]
    else:
        prices_benchmark_daily_ret.loc[i, 'Portfolio Value'] = prices_benchmark_daily_ret.loc[i, 'Daily Pct Return'] * \
                                                prices_benchmark_daily_ret.loc[i - 1, 'Portfolio Value']
        
prices_benchmark_daily_ret = prices_benchmark_daily_ret.iloc[:-(len(prices_benchmark_daily_ret)-len(daily_weights_returns))]
prices_benchmark_daily_ret['index'] = daily_weights_returns.index

# Plot portfolio value and benchmark
spacing = 10
fig, ax = plt.subplots(figsize=(10, 6))
plt1 = plt.plot(prices_benchmark_daily_ret['index'], prices_benchmark_daily_ret['Portfolio Value'], label=benchmark[0])
plt2 = plt.plot(prices_benchmark_daily_ret['index'], daily_weights_returns['Portfolio Value'], label='Portfolio Value')
plt.legend()
plt.xticks(rotation=45)

# Reduce number of labels
ax.tick_params(top=False, bottom=False, left=False, right=False, labelleft=True, labelbottom=True)
functions = [plt1, plt2]
for fn in functions:
    visible = ax.xaxis.get_ticklabels()[::spacing]
    for label in ax.xaxis.get_ticklabels():
        if label not in visible:
            label.set_visible(False)

plt.title('Portfolio Performance')
plt.xlabel('Date')
plt.ylabel('Max Sharpe Portfolio Value')
plt.show()

# Calculate portfolio statistics
# Calculate max drawdown
daily_weights_returns.index = daily_ret.index
rolling_max = daily_weights_returns['Portfolio Value'].rolling(252, min_periods=1).max()
daily_drawdown = daily_weights_returns['Portfolio Value']/rolling_max - 1.0
max_daily_drawdown = daily_drawdown.rolling(252, min_periods=1).min()
daily_drawdown.plot()
plt.xticks(rotation=45)
plt.title('Portfolio Max Drawdown')
plt.show()
print('------------------------------------------')
print('Max portfolio drawdown: {:.2%}'.format(round((daily_drawdown.min()), 2)))

# Calculate portfolio return statistics
# Annual portfolio returns
daily_weights_returns['Daily Pct Return'] = daily_weights_returns['Daily Pct Return']-1
daily_weights_returns = daily_weights_returns.reset_index(drop=True)
daily_weights_returns['index'] = pd.to_datetime(daily_weights_returns['index'])
daily_weights_returns.set_index('index', inplace=True)
portfolio_annual_return = daily_weights_returns['Daily Pct Return']\
    .groupby(pd.Grouper(freq='Y')).apply(np.sum).mean()
print('Average annual portfolio return: {:.2%}'.format(portfolio_annual_return))

# Portfolio Sharpe
portfolio_sharpe = daily_weights_returns['Daily Pct Return'].mean() / daily_weights_returns['Daily Pct Return'].std()
portfolio_sharpe_annualised = (250**0.5) * portfolio_sharpe
print('Portfolio Sharpe ratio: {:.3}'.format(portfolio_sharpe_annualised))
print('------------------------------------------')

# Cumulative returns graph
ax1 = plt.figure().add_axes([0.1, 0.1, 0.8, 0.8])
ax1.hist(daily_weights_returns['Daily Pct Return'], bins=120)
plt.axvline(0, color='r', linestyle='solid', linewidth=1)
plt.text(0.02, 180, 'Skew: {:.2}'.format(skew(daily_weights_returns['Daily Pct Return'])))
plt.text(0.02, 150, 'Kurtosis: {:.3}'.format(kurtosis(daily_weights_returns['Daily Pct Return'])))
ax1.set_xlabel('Portfolio Returns')
ax1.set_ylabel('Freq')
ax1.set_title('Portfolio Returns Histogram')
plt.show()
